# -*- eval: (setq org-download-image-dir (concat default-directory "./static/Flask-0.1/")); -*-
:PROPERTIES:
:ID:       678C3820-E6CB-41A3-82FB-F8C30F15A846
:END:
#+LATEX_CLASS: my-article
#+DATE: <2020-06-16 Tue 10:57>
#+TITLE: Flask-0.1

#+BEGIN_SRC python :results values list :exports no-eval
# -*- coding: utf-8 -*-
"""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""
import os
import sys
import pkg_resources
from threading import local
from jinja2 import Environment, PackageLoader
from werkzeug import Request, Response, LocalStack, LocalProxy
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# try to import the json helpers
try:
    from simplejson import loads as load_json, dumps as dump_json
except ImportError:
    try:
        from json import loads as load_json, dumps as dump_json
    except ImportError:
        pass

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect, secure_filename, cached_property, \
    html, import_string, generate_password_hash, check_password_hash
from jinja2 import Markup, escape


class FlaskRequest(Request):
    """The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.
    """

    def __init__(self, environ):
        Request.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class FlaskResponse(Response):
    """The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.
    """
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def jsonified(**values):
    """Returns a json response"""
    return current_app.response_class(dump_json(values),
                                      mimetype='application/json')


def flash(message):
    """Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.
    """
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """Renders a template from the template folder with the given
    context.
    """
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """Renders a template from the given template source string
    with the given context.
    """
    return current_app.jinja_env.from_string(source).render(context)


class Flask(object):
    """The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the application
    and optionally a configuration.  When it's created it sets up the
    template engine and provides ways to register view functions.
    """

    #: the class that is used for request objects
    request_class = FlaskRequest

    #: the class that is used for response objects
    response_class = FlaskResponse

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_'])

    def __init__(self, package_name):
        self.debug = False
        self.package_name = package_name
        self.view_functions = {}
        self.error_handlers = {}
        self.request_init_funcs = []
        self.request_shutdown_funcs = []
        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(
                Rule(self.static_path + '/<filename>',
                     build_only=True,
                     endpoint='static'))

        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     ,**self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            request=request,
            session=session,
            g=g,
            get_flashed_messages=get_flashed_messages)

    def create_jinja_loader(self):
        """Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """
        return PackageLoader(self.package_name)

    def run(self, host='localhost', port=5000, **options):
        """Runs the application on a local development server"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path: (self.package_name, 'static')
            }
            options.setdefault('use_reloader', self.debug)
            options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    @cached_property
    def test(self):
        """A test client for this application"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """Opens a resource from the application's resource folder"""
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """Creates or opens a new session.  Default implementation requires
        that `securecookie.secret_key` is set.
        """
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request,
                                            self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """Saves the session if it needs updates."""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def route(self, rule, **options):
        """A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'
        """

        def decorator(f):
            if 'endpoint' not in options:
                options['endpoint'] = f.__name__
                self.url_map.add(Rule(rule, **options))
                self.view_functions[options['endpoint']] = f
            return f

        return decorator

    def errorhandler(self, code):
        """A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404
        """

        def decorator(f):
            self.error_handlers[code] = f
            return f

        return decorator

    def request_init(self, f):
        """Registers a function to run before each request."""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """Register a function to be run after each request."""
        self.request_shutdown_funcs.append(f)
        return f

    def match_request(self):
        """Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

        """Does the request dispatching.  Matches the URL and returns the
        def dispatch_request(self):
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.
        """
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """Can be overridden in order to modify the response object
        before it's sent to the WSGI server.
        """
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)
        """
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
                response = self.make_response(rv)
                response = self.process_response(response)
            return response(environ, start_response)
        finally:
            _request_ctx_stack.pop()

    def __call__(self, environ, start_response):
        """Shortcut for :attr:`wsgi_app`"""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#: create a new flask applications.  We pass it the name of our module
#: so that flask knows where to look for templates and static files.
app = Flask(__name__)


@app.route('/', methods=['GET'])
def index():
    """Show an overview page"""
    # return render_template('index.html')
    return "index"


@app.route('/hello/', methods=['GET', 'POST'])
def hello_user():
    """Ask the user for a name and redirect to :func:`hello`"""
    # if request.method == 'POST':
    #     return redirect(url_for('hello', name=request.form['name']))
    # return render_template('hello.html', name=None)
    return "hello"


@app.route('/hello/<name>', methods=['GET'])
def hello(name):
    """Greet name friendly"""
    # return render_template('hello.html', name=name)
    return "hello name"


# if __name__ == '__main__':
app.run(debug=True)
#+END_SRC

* 注册路由
:PROPERTIES:
:ID:       4164ADC2-9BCD-4829-891D-AA8A47D8FE17
:END:

#+BEGIN_SRC python :results values list :exports no-eval
class Flask(object)
    ...
    def route(self, rule, **options):
        """A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'
        """

        def decorator(f):
            if 'endpoint' not in options:
                options['endpoint'] = f.__name__
                self.url_map.add(Rule(rule, **options))
                self.view_functions[options['endpoint']] = f
            return f

        return decorator
    ...
#+END_SRC

Flask 的路由装饰器， ~self.url_map.add(Rule(rule, **options))~ 调用了 ~Map~ 类中的 ~add~ 方法，其中参数 ~rulefactory~ 为 ~Rule~ 类实例。

#+BEGIN_SRC python :results values list :exports no-eval
class Map()
    ...
    def add(self, rulefactory):
        """Add a new rule or factory to the map and bind it.  Requires that the
        rule is not bound to another map.

        :param rulefactory: a :class:`Rule` or :class:`RuleFactory`
        """
        for rule in rulefactory.get_rules(self):
            rule.bind(self)
            self._rules.append(rule)
            self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)
        self._remap = True
    ...
#+END_SRC

~rulefactory.get_rules(self)~ 只是返回 ~Rule~ 类实例自身。如下所示：

#+BEGIN_SRC python :results values list :exports no-eval
class Rule(object)
    ...
    def get_rules(self, map):
        yield self
    ...
#+END_SRC

~self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)~ 。

~self._rules_by_endpoint~ 初始值为 ~<type 'dict'>: {'static': [<Rule '/static/<filename>' -> static>]}~ 。

~rule.endpoint~ 即为 ~Rule(string="/", methods=['GET'], endpoint="index")~ 。

~endpoint~ 值为 ~index~ 。

运行后  ~self._rules_by_endpoint~ 为 ~<type 'dict'>: {'index': [<Rule (unbound)>], 'static': [<Rule '/static/<filename>' -> static>]}~ 。

* environ 参数传递
:PROPERTIES:
:ID:       886C5873-A3C5-4F74-BDD5-CA81F9B97CCB
:END:
** class Flask(object)
:PROPERTIES:
:ID:       8649F288-4575-4A87-A2A4-6C45617983CB
:END:

附件： [[file:flask-0.1.py][flask-0.1.py]]

#+BEGIN_SRC python :results values list :exports no-eval
class Flask(object):
    ...

    def run(self, host='localhost', port=5000, **options):
        """Runs the application on a local development server"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path: (self.package_name, 'static')
            }
            options.setdefault('use_reloader', self.debug)
            options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    ...
#+END_SRC

~app.run(debug=True)~ 调用 werkzeug 包中的 ~run_simple~ ，将 ~self(即app)~ 实例自身传入。
同时将 ~options~ 这个字典传入：

#+DOWNLOADED: /var/folders/2h/_7667pjd23s4wd9mpdwy401w0000gn/T/screenshot.jpg @ 2019-10-23 19:11:12
[[file:./static/Flask-0.1/screenshot_2019-10-23_19-11-12.jpg]]

** ~werkzeug.serving:run_simple~
:PROPERTIES:
:ID:       26079EFE-D84B-4A77-9389-403CFB405FB7
:END:

附件：[[file:serving.py][serving.py]]

#+BEGIN_SRC python :results values list :exports no-eval
def run_simple(hostname, port, application, use_reloader=False,
               use_debugger=False, use_evalex=True,
               extra_files=None, reloader_interval=1, threaded=False,
               processes=1, request_handler=None, static_files=None,
               passthrough_errors=False, ssl_context=None):
    """Start an application using wsgiref and with an optional reloader.  This
    wraps `wsgiref` to fix the wrong default reporting of the multithreaded
    WSGI variable and adds optional multithreading and fork support.

    .. versionadded:: 0.5
       `static_files` was added to simplify serving of static files as well
       as `passthrough_errors`.

    .. versionadded:: 0.6
       support for SSL was added.

    :param hostname: The host for the application.  eg: ``'localhost'``
    :param port: The port for the server.  eg: ``8080``
    :param application: the WSGI application to execute
    :param use_reloader: should the server automatically restart the python
                         process if modules were changed?
    :param use_debugger: should the werkzeug debugging system be used?
    :param use_evalex: should the exception evaluation feature be enabled?
    :param extra_files: a list of files the reloader should watch
                        additionally to the modules.  For example configuration
                        files.
    :param reloader_interval: the interval for the reloader in seconds.
    :param threaded: should the process handle each request in a separate
                     thread?
    :param processes: number of processes to spawn.
    :param request_handler: optional parameter that can be used to replace
                            the default one.  You can use this to replace it
                            with a different
                            :class:`~BaseHTTPServer.BaseHTTPRequestHandler`
                            subclass.
    :param static_files: a dict of paths for static files.  This works exactly
                         like :class:`SharedDataMiddleware`, it's actually
                         just wrapping the application in that middleware before
                         serving.
    :param passthrough_errors: set this to `True` to disable the error catching.
                               This means that the server will die on errors but
                               it can be useful to hook debuggers in (pdb etc.)
    :param ssl_context: an SSL context for the connection. Either an OpenSSL
                        context, the string ``'adhoc'`` if the server should
                        automatically create one, or `None` to disable SSL
                        (which is the default).
    """
    if use_debugger:
        from werkzeug.debug import DebuggedApplication
        application = DebuggedApplication(application, use_evalex)
    if static_files:
        from werkzeug.wsgi import SharedDataMiddleware
        application = SharedDataMiddleware(application, static_files)

    def inner():
        make_server(hostname, port, application, threaded,
                    processes, request_handler,
                    passthrough_errors, ssl_context).serve_forever()

    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':
        display_hostname = hostname != '*' and hostname or 'localhost'
        if ':' in display_hostname:
            display_hostname = '[%s]' % display_hostname
        _log('info', ' * Running on %s://%s:%d/', ssl_context is None
             and 'http' or 'https', display_hostname, port)
    if use_reloader:
        # Create and destroy a socket so that any exceptions are raised before
        # we spawn a separate Python interpreter and lose this ability.
        test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        test_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        test_socket.bind((hostname, port))
        test_socket.close()
        run_with_reloader(inner, extra_files, reloader_interval)
    else:
        inner()
#+END_SRC

在 ~run_simple~ 中定义了 ~inner~ 函数，这个是关键。
因为 ~inner~ 一旦被调用，其内部的：

#+BEGIN_SRC python :results values list :exports no-eval
make_server(hostname, port, application, threaded,
            processes, request_handler,
            passthrough_errors, ssl_context).serve_forever()
#+END_SRC

就会立即执行。
而 ~inner~ 的调用在 ~user_reloader~ 为 ~True~ 的情况下是通过 ~run_with_reloader(inner, extra_files, reloader_interval)~ 的：

#+BEGIN_SRC python :results values list :exports no-eval
def run_with_reloader(main_func, extra_files=None, interval=1):
    """Run the given function in an independent python interpreter."""
    if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':
        thread.start_new_thread(main_func, ())
        try:
            reloader_loop(extra_files, interval)
        except KeyboardInterrupt:
            return
    try:
        sys.exit(restart_with_reloader())
    except KeyboardInterrupt:
        pass
#+END_SRC

可以看出是通过 ~thread.start_new_thread~ 来调用 ~inner~ 函数的。

** ~werkzeug.serving:make_server~
:PROPERTIES:
:ID:       2E45BED6-ED3D-4688-8337-30B174F84D9B
:END:

#+BEGIN_SRC python :results values list :exports no-eval
make_server(hostname, port, application, threaded,
            processes, request_handler,
            passthrough_errors, ssl_context).serve_forever()
#+END_SRC

~make_server~ 被调用时，参数 ~application~ 是被 ~DebuggedApplication~ 和 ~SharedDataMiddleware~ 包裹过的。

#+DOWNLOADED: /var/folders/2h/_7667pjd23s4wd9mpdwy401w0000gn/T/screenshot.jpg @ 2019-10-24 12:09:34
[[file:./static/Flask-0.1/screenshot_2019-10-24_12-09-34.jpg]]

#+BEGIN_SRC python :results values list :exports no-eval
def make_server(host, port, app=None, threaded=False, processes=1,
                request_handler=None, passthrough_errors=False,
                ssl_context=None):
    """Create a new server instance that is either threaded, or forks
    or just processes one request after another.
    """
    if threaded and processes > 1:
        raise ValueError("cannot have a multithreaded and "
                         "multi process server.")
    elif threaded:
        return ThreadedWSGIServer(host, port, app, request_handler,
                                  passthrough_errors, ssl_context)
    elif processes > 1:
        return ForkingWSGIServer(host, port, app, processes, request_handler,
                                 passthrough_errors, ssl_context)
    else:
        return BaseWSGIServer(host, port, app, request_handler,
                              passthrough_errors, ssl_context)
#+END_SRC

在 ~make_server~ 内调用 ~BaseWSGIServer~ ，此时的参数如下：

#+DOWNLOADED: /var/folders/2h/_7667pjd23s4wd9mpdwy401w0000gn/T/screenshot.jpg @ 2019-10-24 12:16:57
[[file:./static/Flask-0.1/screenshot_2019-10-24_12-16-57.jpg]]

调用 ~BaseWSGIServer~ 生成类实例后，会立即执行实例的 ~serve_forever~ 方法。

** ~werkzeug.serving:BaseWSGIServer~
:PROPERTIES:
:ID:       A0086524-BBFA-4656-995B-897D5E2F3B68
:END:
   - Note taken on [2020-07-22 Wed 18:06] \\
     注 2：初始化时 ~handler = WSGIRequestHandler~ 。
   - Note taken on [2019-10-24 Thu 12:34] \\
     注 1： ~BaseWSGIServer~ 继承了 ~HTTPServer~ 。

#+BEGIN_SRC python :results values list :exports no-eval
class BaseWSGIServer(HTTPServer, object): # 注1
    """Simple single-threaded, single-process WSGI server."""
    multithread = False
    multiprocess = False

    def __init__(self, host, port, app, handler=None,
                 passthrough_errors=False, ssl_context=None):
        if handler is None:
            handler = WSGIRequestHandler
            self.address_family = select_ip_version(host, port)
            HTTPServer.__init__(self, (host, int(port)), handler)
            self.app = app
            self.passthrough_errors = passthrough_errors

        if ssl_context is not None:
            try:
                from OpenSSL import tsafe
            except ImportError:
                raise TypeError('SSL is not available if the OpenSSL '
                                'library is not installed.')
            if ssl_context == 'adhoc':
                ssl_context = generate_adhoc_ssl_context()
                self.socket = tsafe.Connection(ssl_context, self.socket)
                self.ssl_context = ssl_context
        else:
            self.ssl_context = None

    def log(self, type, message, *args):
        _log(type, message, *args)

    def serve_forever(self):
        try:
            HTTPServer.serve_forever(self)
        except KeyboardInterrupt:
            pass

    def handle_error(self, request, client_address):
        if self.passthrough_errors:
            raise
        else:
            return HTTPServer.handle_error(self, request, client_address)

    def get_request(self):
        con, info = self.socket.accept()
        if self.ssl_context is not None:
            con = _SSLConnectionFix(con)
        return con, info
#+END_SRC

** ~lib/python2.7/BaseHTTPServer:HTTPServer~
:PROPERTIES:
:ID:       1A33AF10-E7BF-4509-8CF2-347D1FDF93E4
:END:
   - Note taken on [2019-10-24 Thu 12:41] \\
     注 2: ~HTTPServer~ 继承自 ~SocketServer.TCPServer~ 。

#+BEGIN_SRC python :results values list :exports no-eval
class HTTPServer(SocketServer.TCPServer): # 注2

    allow_reuse_address = 1    # Seems to make sense in testing environment

    def server_bind(self):
        """Override server_bind to store the server name."""
        SocketServer.TCPServer.server_bind(self)
        host, port = self.socket.getsockname()[:2]
        self.server_name = socket.getfqdn(host)
        self.server_port = port
#+END_SRC

** ~lib/python2.7/BaseHTTPServer:TCPServer~
:PROPERTIES:
:ID:       7065CEF5-D485-4B20-83BE-7BE8BC064E89
:END:

   - Note taken on [2019-10-24 Thu 13:31] \\
     注 3: ~TCPServer~ 继承自 ~BaseServer~ 。

#+BEGIN_SRC python :results values list :exports no-eval
class TCPServer(BaseServer): # 注3

    """Base class for various socket-based server classes.

    Defaults to synchronous IP stream (i.e., TCP).

    Methods for the caller:

    - __init__(server_address, RequestHandlerClass, bind_and_activate=True)
    - serve_forever(poll_interval=0.5)
    - shutdown()
    - handle_request()  # if you don't use serve_forever()
    - fileno() -> int   # for select()

    Methods that may be overridden:

    - server_bind()
    - server_activate()
    - get_request() -> request, client_address
    - handle_timeout()
    - verify_request(request, client_address)
    - process_request(request, client_address)
    - shutdown_request(request)
    - close_request(request)
    - handle_error()

    Methods for derived classes:

    - finish_request(request, client_address)

    Class variables that may be overridden by derived classes or
    instances:

    - timeout
    - address_family
    - socket_type
    - request_queue_size (only for stream sockets)
    - allow_reuse_address

    Instance variables:

    - server_address
    - RequestHandlerClass
    - socket

    """

    address_family = socket.AF_INET

    socket_type = socket.SOCK_STREAM

    request_queue_size = 5

    allow_reuse_address = False

    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):
        """Constructor.  May be extended, do not override."""
        BaseServer.__init__(self, server_address, RequestHandlerClass)
        self.socket = socket.socket(self.address_family,
                                    self.socket_type)
        if bind_and_activate:
            try:
                self.server_bind()
                self.server_activate()
            except:
                self.server_close()
                raise

    def server_bind(self):
        """Called by constructor to bind the socket.

        May be overridden.

        """
        if self.allow_reuse_address:
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind(self.server_address)
            self.server_address = self.socket.getsockname()

    def server_activate(self):
        """Called by constructor to activate the server.

        May be overridden.

        """
        self.socket.listen(self.request_queue_size)

    def server_close(self):
        """Called to clean-up the server.

        May be overridden.

        """
        self.socket.close()

    def fileno(self):
        """Return socket file number.

        Interface required by select().

        """
        return self.socket.fileno()

    def get_request(self):
        """Get the request and client address from the socket.

        May be overridden.

        """
        return self.socket.accept()

    def shutdown_request(self, request):
        """Called to shutdown and close an individual request."""
        try:
            #explicitly shutdown.  socket.close() merely releases
            #the socket and waits for GC to perform the actual close.
            request.shutdown(socket.SHUT_WR)
        except socket.error:
            pass #some platforms may raise ENOTCONN here
        self.close_request(request)

    def close_request(self, request):
        """Called to clean up an individual request."""
        request.close()
#+END_SRC

#+RESULTS:
:

#+CAPTION: RequstHandlerClass
#+DOWNLOADED: /var/folders/2h/_7667pjd23s4wd9mpdwy401w0000gn/T/screenshot.jpg @ 2019-10-24 12:57:09
[[file:./static/Flask-0.1/screenshot_2019-10-24_12-57-09.jpg]]
<<RequstHandlerClass>>

~RequstHandlerClass~ 参数在中被定义。

** ~lib/python2.7/BaseHTTPServer:BaseServer~
:PROPERTIES:
:ID:       6D1635D6-8FB3-4DC3-8C84-316652CFF413
:END:

#+BEGIN_SRC python :results raw drawer values list :exports no-eval
class BaseServer:

    """Base class for server classes.

    Methods for the caller:

    - __init__(server_address, RequestHandlerClass)
    - serve_forever(poll_interval=0.5)
    - shutdown()
    - handle_request()  # if you do not use serve_forever()
    - fileno() -> int   # for select()

    Methods that may be overridden:

    - server_bind()
    - server_activate()
    - get_request() -> request, client_address
    - handle_timeout()
    - verify_request(request, client_address)
    - server_close()
    - process_request(request, client_address)
    - shutdown_request(request)
    - close_request(request)
    - handle_error()

    Methods for derived classes:

    - finish_request(request, client_address)

    Class variables that may be overridden by derived classes or
    instances:

    - timeout
    - address_family
    - socket_type
    - allow_reuse_address

    Instance variables:

    - RequestHandlerClass
    - socket

    """

    timeout = None

    def __init__(self, server_address, RequestHandlerClass):
        """Constructor.  May be extended, do not override."""
        self.server_address = server_address
        self.RequestHandlerClass = RequestHandlerClass
        self.__is_shut_down = threading.Event()
        self.__shutdown_request = False

    def server_activate(self):
        """Called by constructor to activate the server.

        May be overridden.

        """
        pass

    def serve_forever(self, poll_interval=0.5):
        """Handle one request at a time until shutdown.

        Polls for shutdown every poll_interval seconds. Ignores
        self.timeout. If you need to do periodic tasks, do them in
        another thread.
        """
        self.__is_shut_down.clear()
        try:
            while not self.__shutdown_request:
                # XXX: Consider using another file descriptor or
                # connecting to the socket to wake this up instead of
                # polling. Polling reduces our responsiveness to a
                # shutdown request and wastes cpu at all other times.
                r, w, e = _eintr_retry(select.select, [self], [], [],
                                       poll_interval)
                # bpo-35017: shutdown() called during select(), exit immediately.
                if self.__shutdown_request:
                    break
                if self in r:
                    self._handle_request_noblock()
        finally:
            self.__shutdown_request = False
            self.__is_shut_down.set()

    def shutdown(self):
        """Stops the serve_forever loop.

        Blocks until the loop has finished. This must be called while
        serve_forever() is running in another thread, or it will
        deadlock.
        """
        self.__shutdown_request = True
        self.__is_shut_down.wait()

    # The distinction between handling, getting, processing and
    # finishing a request is fairly arbitrary.  Remember:
    #
    # - handle_request() is the top-level call.  It calls
    #   select, get_request(), verify_request() and process_request()
    # - get_request() is different for stream or datagram sockets
    # - process_request() is the place that may fork a new process
    #   or create a new thread to finish the request
    # - finish_request() instantiates the request handler class;
    #   this constructor will handle the request all by itself

    def handle_request(self):
        """Handle one request, possibly blocking.

        Respects self.timeout.
        """
        # Support people who used socket.settimeout() to escape
        # handle_request before self.timeout was available.
        timeout = self.socket.gettimeout()
        if timeout is None:
            timeout = self.timeout
        elif self.timeout is not None:
            timeout = min(timeout, self.timeout)
        fd_sets = _eintr_retry(select.select, [self], [], [], timeout)
        if not fd_sets[0]:
            self.handle_timeout()
            return
        self._handle_request_noblock()

    def _handle_request_noblock(self):
        """Handle one request, without blocking.

        I assume that select.select has returned that the socket is
        readable before this function was called, so there should be
        no risk of blocking in get_request().
        """
        try:
            request, client_address = self.get_request()
        except socket.error:
            return
        if self.verify_request(request, client_address):
            try:
                self.process_request(request, client_address)
            except:
                self.handle_error(request, client_address)
                self.shutdown_request(request)
        else:
            self.shutdown_request(request)

    def handle_timeout(self):
        """Called if no new request arrives within self.timeout.

        Overridden by ForkingMixIn.
        """
        pass

    def verify_request(self, request, client_address):
        """Verify the request.  May be overridden.

        Return True if we should proceed with this request.

        """
        return True

    def process_request(self, request, client_address):
        """Call finish_request.

        Overridden by ForkingMixIn and ThreadingMixIn.

        """
        self.finish_request(request, client_address)
        self.shutdown_request(request)

    def server_close(self):
        """Called to clean-up the server.

        May be overridden.

        """
        pass

    def finish_request(self, request, client_address):
        """Finish one request by instantiating RequestHandlerClass."""
        self.RequestHandlerClass(request, client_address, self)

    def shutdown_request(self, request):
        """Called to shutdown and close an individual request."""
        self.close_request(request)

    def close_request(self, request):
        """Called to clean up an individual request."""
        pass

    def handle_error(self, request, client_address):
        """Handle an error gracefully.  May be overridden.

        The default is to print a traceback and continue.

        """
        print '-'*40
        print 'Exception happened during processing of request from',
        print client_address
        import traceback
        traceback.print_exc() # XXX But this goes to stderr!
        print '-'*40
#+END_SRC

可以看到最后的调用链： ~serve_forever~ -> ~_handle_request_noblock~ -> ~process_request~ -> ~finish_request~ 。

#+BEGIN_SRC python :results raw drawer values list :exports no-eval
    def finish_request(self, request, client_address):
        """Finish one request by instantiating RequestHandlerClass."""
        self.RequestHandlerClass(request, client_address, self)
#+END_SRC

[[RequstHandlerClass][See： RequstHandlerClass]]

从前面可以知道 ~RequstHandlerClass~ 是 ~werkzeug.serving:WSGIRequestHandler~ 。

** TODO werkzeug 包如何将 environ 传入给 app
:PROPERTIES:
:ID:       8C58EEC8-A68D-417F-8052-5D810A35BC28
:END:
* 路由响应
:PROPERTIES:
:ID:       8D75C189-0C59-42E7-9067-A112601F7DB7
:END:

#+BEGIN_SRC python :results values list :exports no-eval
  class Flask(object):
      ...

      def wsgi_app(self, environ, start_response):
          """The actual WSGI application.  This is not implemented in
         `__call__` so that middlewares can be applied:

              app.wsgi_app = MyMiddleware(app.wsgi_app)
          """
          _request_ctx_stack.push(_RequestContext(self, environ))
          try:
              rv = self.preprocess_request()
              if rv is None:
                  rv = self.dispatch_request()
              response = self.make_response(rv)
              response = self.process_response(response)
              return response(environ, start_response)
          finally:
              _request_ctx_stack.pop()

      ...
#+END_SRC

在 ~Flask.wsgi_app~ 中， ~_request_ctx_stack.push(_RequestContext(self, environ))~ 实例化 ~_RequestContext~ 类。

#+DOWNLOADED: file:///Users/c/Pictures/_request_ctx_stack.png @ 2019-06-30 16:26:02
[[file:./static/Flask-0.1/_request_ctx_stack_2019-06-30_16-26-02.png]]

#+BEGIN_SRC python :results values list :exports no-eval
class _RequestContext(object):
    """The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None
#+END_SRC

在该类的初始化方法中， ~self.url_adapter = app.url_map.bind_to_environ(environ)~ 调用 ~app.url_map.bind_to_environ~ 方法。
~app.url_map~ 为 ~Map~ 类。
~Map~ 类的 ~bind_to_environ~ 方法定义如下：

#+BEGIN_SRC python :results values list :exports no-eval
class Map(object):
    ...

    def bind_to_environ(self, environ, server_name=None, subdomain=None):
        """Like :meth:`bind` but you can pass it an WSGI environment and it
        will fetch the information from that dictionary.  Note that because of
        limitations in the protocol there is no way to get the current
        subdomain and real `server_name` from the environment.  If you don't
        provide it, Werkzeug will use `SERVER_NAME` and `SERVER_PORT` (or
        `HTTP_HOST` if provided) as used `server_name` with disabled subdomain
        feature.

        If `subdomain` is `None` but an environment and a server name is
        provided it will calculate the current subdomain automatically.
        Example: `server_name` is ``'example.com'`` and the `SERVER_NAME`
        in the wsgi `environ` is ``'staging.dev.example.com'`` the calculated
        subdomain will be ``'staging.dev'``.

        If the object passed as environ has an environ attribute, the value of
        this attribute is used instead.  This allows you to pass request
        objects.  Additionally `PATH_INFO` added as a default of the
        :class:`MapAdapter` so that you don't have to pass the path info to
        the match method.

        .. versionchanged:: 0.5
            previously this method accepted a bogus `calculate_subdomain`
            parameter that did not have any effect.  It was removed because
            of that.

        :param environ: a WSGI environment.
        :param server_name: an optional server name hint (see above).
        :param subdomain: optionally the current subdomain (see above).
        """
        environ = _get_environ(environ)
        if server_name is None:
            if 'HTTP_HOST' in environ:
                server_name = environ['HTTP_HOST']
            else:
                server_name = environ['SERVER_NAME']
                if (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not \
                   in (('https', '443'), ('http', '80')):
                    server_name += ':' + environ['SERVER_PORT']
        elif subdomain is None:
            wsgi_server_name = environ.get('HTTP_HOST', environ['SERVER_NAME'])
            cur_server_name = wsgi_server_name.split(':', 1)[0].split('.')
            real_server_name = server_name.split(':', 1)[0].split('.')
            offset = -len(real_server_name)
            if cur_server_name[offset:] != real_server_name:
                raise ValueError('the server name provided (%r) does not '
                                 'match the server name from the WSGI '
                                 'environment (%r)' %
                                 (server_name, wsgi_server_name))
            subdomain = '.'.join(filter(None, cur_server_name[:offset]))
        return Map.bind(self, server_name, environ.get('SCRIPT_NAME'),
                        subdomain, environ['wsgi.url_scheme'],
                        environ['REQUEST_METHOD'], environ.get('PATH_INFO'))

    ...
#+END_SRC

紧接着调用 ~Map~ 类的 ~bind~ 方法。
此时的参数如下所示：

#+BEGIN_SRC python :results values list :exports no-eval
self: Map([[<Rule '/static/<filename>' -> static>,
            <Rule '/' (HEAD, GET) -> index>,
            <Rule '/hello/' (POST, HEAD, GET) -> hello_user>,
            <Rule '/hello/<name>' (HEAD, GET) -> hello>]])
#+END_SRC

- eviron:

#+DOWNLOADED: file:///Users/c/Pictures/environ.png @ 2019-06-30 18:48:53
[[file:./static/Flask-0.1/environ_2019-06-30_18-48-53.png]]

- server_name: 'localhost:5000'

- subdomain: None

~bind~ 方法定义如下：

#+BEGIN_SRC python :results values list :exports no-eval
class Map(object):
    ...
    def bind(self, server_name, script_name=None, subdomain=None,
             url_scheme='http', default_method='GET', path_info=None):
        """Return a new :class:`MapAdapter` with the details specified to the
        call.  Note that `script_name` will default to ``'/'`` if not further
        specified or `None`.  The `server_name` at least is a requirement
        because the HTTP RFC requires absolute URLs for redirects and so all
        redirect exceptions raised by Werkzeug will contain the full canonical
        URL.

        If no path_info is passed to :meth:`match` it will use the default path
        info passed to bind.  While this doesn't really make sense for
        manual bind calls, it's useful if you bind a map to a WSGI
        environment which already contains the path info.

        `subdomain` will default to the `default_subdomain` for this map if
        no defined. If there is no `default_subdomain` you cannot use the
        subdomain feature.
        """
        if subdomain is None:
            subdomain = self.default_subdomain
        if script_name is None:
            script_name = '/'
        return MapAdapter(self, server_name, script_name, subdomain,
                          url_scheme, path_info, default_method)
    ...
#+END_SRC

紧接着调用 =MapAdapter= 类的初始化方法。

#+BEGIN_SRC python :results values list :exports no-eval
class MapAdapter(object):
    """Returned by :meth:`Map.bind` or :meth:`Map.bind_to_environ` and does
    the URL matching and building based on runtime information.
    """

    def __init__(self, map, server_name, script_name, subdomain,
                 url_scheme, path_info, default_method):
        self.map = map
        self.server_name = server_name
        if not script_name.endswith('/'):
            script_name += '/'
        self.script_name = script_name
        self.subdomain = subdomain
        self.url_scheme = url_scheme
        self.path_info = path_info or u''
        self.default_method = default_method
#+END_SRC

此时的参数如下所示：

#+CAPTION: MapAdapter 类实例调用 match 时实例的参数
<<MapAdapter 类实例调用 match 时实例的参数>>

- self: <werkzeug.routing.MapAdapter object at 0x10dbc3410>

-
#+BEGIN_SRC python :results values list :exports no-eval
map: Map([[<Rule '/static/<filename>' -> static>,
           <Rule '/' (HEAD, GET) -> index>,
           <Rule '/hello/' (POST, HEAD, GET) -> hello_user>,
           <Rule '/hello/<name>' (HEAD, GET) -> hello>]])
#+END_SRC

- script_name: ''

- subdomain: ''

- url_sheme: ''

- path_info: 'hello/test'

- default_method: 'GET'

最终返回 =MapAdapter= 类实例赋予变量 url_adapter。

* URL 匹配
:PROPERTIES:
:ID:       69C2FE0D-2D91-45B6-AAEC-43BA27275104
:END:

#+BEGIN_SRC python :results values list :exports no-eval
class Flask(object):
    ...
    def wsgi_app(self, environ, start_response):
        """The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)
        """
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
                response = self.make_response(rv)
                response = self.process_response(response)
            return response(environ, start_response)
        finally:
            _request_ctx_stack.pop()
    ...
#+END_SRC

#+BEGIN_SRC python :results values list :exports no-eval
class Flask(object):
    ...
    def dispatch_request(self):
        """Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)
    ...
#+END_SRC

#+BEGIN_SRC python :results values list :exports no-eval
class Flask(object):
    ...
    def match_request(self):
        """Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """
        rv = _request_ctx_stack.top.url_adapter.match()  # _request_ctx_stack.top.url_adapter.match() => <type 'tuple'>: ('hello', {'name': u'test'})
        request.endpoint, request.view_args = rv
        return rv
    ...
#+END_SRC

~rv = _request_ctx_stack.top.url_adapter.match()~ 调用 ~MapAdapter~ 类的 match 方法，如下所示：

[[MapAdapter 类实例调用 match 时实例的参数][See： MapAdapter 类实例调用 match 时实例的参数]]

#+BEGIN_SRC python :results values list :exports no-eval
class MapAdapter(object):
    ...

    def match(self, path_info=None, method=None, return_rule=False):
        """The usage is simple: you just pass the match method the current
        path info as well as the method (which defaults to `GET`).  The
        following things can then happen:

        - you receive a `NotFound` exception that indicates that no URL is
          matching.  A `NotFound` exception is also a WSGI application you
          can call to get a default page not found page (happens to be the
          same object as `werkzeug.exceptions.NotFound`)

        - you receive a `MethodNotAllowed` exception that indicates that there
          is a match for this URL but not for the current request method.
          This is useful for RESTful applications.

        - you receive a `RequestRedirect` exception with a `new_url`
          attribute.  This exception is used to notify you about a request
          Werkzeug requests from your WSGI application.  This is for example the
          case if you request ``/foo`` although the correct URL is ``/foo/``
          You can use the `RequestRedirect` instance as response-like object
          similar to all other subclasses of `HTTPException`.

        - you get a tuple in the form ``(endpoint, arguments)`` if there is
          a match (unless `return_rule` is True, in which case you get a tuple
          in the form ``(rule, arguments)``)

        If the path info is not passed to the match method the default path
        info of the map is used (defaults to the root URL if not defined
        explicitly).

        All of the exceptions raised are subclasses of `HTTPException` so they
        can be used as WSGI responses.  The will all render generic error or
        redirect pages.

        Here is a small example for matching:

        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.match("/", "GET")
        ('index', {})
        >>> urls.match("/downloads/42")
        ('downloads/show', {'id': 42})

        And here is what happens on redirect and missing URLs:

        >>> urls.match("/downloads")
        Traceback (most recent call last):
          ...
        RequestRedirect: http://example.com/downloads/
        >>> urls.match("/missing")
        Traceback (most recent call last):
          ...
        NotFound: 404 Not Found

        :param path_info: the path info to use for matching.  Overrides the
                          path info specified on binding.
        :param method: the HTTP method used for matching.  Overrides the
                       method specified on binding.
        :param return_rule: return the rule that matched instead of just the
                            endpoint (defaults to `False`).

        .. versionadded:: 0.6
            `return_rule` was added.
        """
        self.map.update()
        if path_info is None:
            path_info = self.path_info
        if not isinstance(path_info, unicode):
            path_info = path_info.decode(self.map.charset, 'ignore')
            method = (method or self.default_method).upper()
            path = u'%s|/%s' % (self.subdomain, path_info.lstrip('/'))
            have_match_for = set()
        for rule in self.map._rules:
            try:
                rv = rule.match(path)
            except RequestSlash:
                raise RequestRedirect(
                    str('%s://%s%s%s/%s/' %
                        (self.url_scheme,
                         self.subdomain and self.subdomain + '.'
                         or '', self.server_name, self.script_name[:-1],
                         url_quote(path_info.lstrip('/'), self.map.charset))))
            if rv is None:
                continue
            if rule.methods is not None and method not in rule.methods:
                have_match_for.update(rule.methods)
                continue
            if self.map.redirect_defaults:
                for r in self.map._rules_by_endpoint[rule.endpoint]:
                    if r.provides_defaults_for(rule) and \
                       r.suitable_for(rv, method):
                        rv.update(r.defaults)
                        subdomain, path = r.build(rv)
                        raise RequestRedirect(
                            str('%s://%s%s%s/%s' %
                                (self.url_scheme, subdomain and subdomain + '.'
                                 or '', self.server_name,
                                 self.script_name[:-1],
                                 url_quote(path.lstrip('/'),
                                           self.map.charset))))
            if rule.redirect_to is not None:
                if isinstance(rule.redirect_to, basestring):

                    def _handle_match(match):
                        value = rv[match.group(1)]
                        return rule._converters[match.group(1)].to_url(value)

                    redirect_url = _simple_rule_re.sub(_handle_match,
                                                       rule.redirect_to)
                else:
                    redirect_url = rule.redirect_to(self, **rv)
                raise RequestRedirect(
                    str(
                        urljoin(
                            '%s://%s%s%s' %
                            (self.url_scheme,
                             self.subdomain and self.subdomain + '.'
                             or '', self.server_name, self.script_name),
                            redirect_url)))
            if return_rule:
                return rule, rv
            else:
                return rule.endpoint, rv
        if have_match_for:
            raise MethodNotAllowed(valid_methods=list(have_match_for))
        raise NotFound()

    ...
#+END_SRC

~rv = rule.match(path)~ 调用 ~Rule~ 类的 ~match~ 方法，如下所示：

#+BEGIN_SRC python :results values list :exports no-eval
class Rule(RuleFactory):
    ...
    def match(self, path):
        """Check if the rule matches a given path. Path is a string in the
        form ``"subdomain|/path(method)"`` and is assembled by the map.

        If the rule matches a dict with the converted values is returned,
        otherwise the return value is `None`.

        :internal:
        """
        if not self.build_only:
            m = self._regex.search(path)
            if m is not None:
                groups = m.groupdict()
                # we have a folder like part of the url without a trailing
                # slash and strict slashes enabled. raise an exception that
                # tells the map to redirect to the same url but with a
                # trailing slash
                if self.strict_slashes and not self.is_leaf and \
                   not groups.pop('__suffix__'):
                    raise RequestSlash()
                # if we are not in strict slashes mode we have to remove
                # a __suffix__
                elif not self.strict_slashes:
                    del groups['__suffix__']

                result = {}
                for name, value in groups.iteritems():
                    try:
                        value = self._converters[name].to_python(value)
                    except ValidationError:
                        return
                    result[str(name)] = value
                if self.defaults is not None:
                    result.update(self.defaults)
                return result
    ...
#+END_SRC

此时参数如下所示：

- self: {Rule}/hello/<name>
- path: {unicode} u'|/hello/test'

~m = self._regex.search(path)~ 就是用正则来匹配 URL。
~m.re.pattern~ => ~u'^\\|\\/hello\\/(?P<name>[^/]{1,})$'~ 。

[[file:./static/Flask-0.1/2019-06-30_22-20-24.png]]

~groups = m.groupdict()~ => ~<type 'dict'>: {u'name': u'test'}~ 。
结果返回到 ~MapAdapter~ 类 ~match~ 方法中的 ~rv = rule.match(path)~ , ~rv~ 得到返回值： ~<type 'tuple'>: ('hello', {'name': u'test'})~ ，
最终 ~Flask~ 类中 ~match_request~ 方法中的 ~rv = _request_ctx_stack.top.url_adapter.match()~ 得到返回值： ~<type 'tuple'>: ('hello', {'name': u'test'})~ 。

* 请求上下文堆栈
:PROPERTIES:
:ID:       DD5E36A4-325C-483E-97D1-E99DB090275C
:END:

#+BEGIN_SRC python :results values list :exports no-eval
  class Flask(object):
      ...
      def wsgi_app(self, environ, start_response):
          _request_ctx_stack.push(_RequestContext(self, environ))
          ...
      ...
#+END_SRC

#+BEGIN_SRC python :results values list :exports no-eval
  class LocalStack(object):
    """This class works similar to a :class:`Local` but keeps a stack
    of objects instead.  This is best explained with an example::

        >>> ls = LocalStack()
        >>> ls.push(42)
        >>> ls.top
        42
        >>> ls.push(23)
        >>> ls.top
        23
        >>> ls.pop()
        23
        >>> ls.top
        42

    They can be force released by using a :class:`LocalManager` or with
    the :func:`release_local` function but the correct way is to pop the
    item from the stack after using.  When the stack is empty it will
    no longer be bound to the current context (and as such released).

    By calling the stack without arguments it returns a proxy that resolves to
    the topmost item on the stack.

    .. versionadded:: 0.6.1
    """

    def __init__(self):
        self._local = Local()
        self._lock = allocate_lock()

    def __release_local__(self):
        self._local.__release_local__()

    def __call__(self):
        def _lookup():
            rv = self.top
            if rv is None:
                raise RuntimeError('object unbound')
            return rv
        return LocalProxy(_lookup)

    def push(self, obj):
        """Pushes a new item to the stack"""
        self._lock.acquire()
        try:
            rv = getattr(self._local, 'stack', None)
            if rv is None:
                self._local.stack = rv = []
            rv.append(obj)
            return rv
        finally:
            self._lock.release()

    def pop(self):
        """Removes the topmost item from the stack, will return the
        old value or `None` if the stack was already empty.
        """
        self._lock.acquire()
        try:
            stack = getattr(self._local, 'stack', None)
            if stack is None:
                return None
            elif len(stack) == 1:
                release_local(self._local)
                return stack[-1]
            else:
                return stack.pop()
        finally:
            self._lock.release()

    @property
    def top(self):
        """The topmost item on the stack.  If the stack is empty,
        `None` is returned.
        """
        try:
            return self._local.stack[-1]
        except (AttributeError, IndexError):
            return None

#+END_SRC

调用 ~LocalStack~ 的 ~push~ 方法。
第一入栈时代理访问到 ~self._local~ 的 ~stack~ 值为空，即 ~rv~ 值为 ~None~ 。

[[file:./static/Flask-0.1/2019-06-30_20-20-13.png]]

此时参数如下所示：

- obj：

[[file:./static/Flask-0.1/obj_2019-06-30_20-22-44.png]]

~rv = getattr(self._local, 'stack', None)~ 调用 ~Local~ 类中 ~__setattr__~ 方法。

#+BEGIN_SRC python :results values list :exports no-eval
class Local(object):
    __slots__ = ('__storage__', '__lock__')

    def __init__(self):
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__lock__', allocate_lock())

    def __iter__(self):
        return self.__storage__.iteritems()

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(get_ident(), None)

    def __getattr__(self, name):
        self.__lock__.acquire()
        try:
            try:
                return self.__storage__[get_ident()][name]
            except KeyError:
                raise AttributeError(name)
        finally:
            self.__lock__.release()

    def __setattr__(self, name, value):
        self.__lock__.acquire()
        try:
            ident = get_ident()
            storage = self.__storage__
            if ident in storage:
                storage[ident][name] = value
            else:
                storage[ident] = {name: value}
        finally:
            self.__lock__.release()

    def __delattr__(self, name):
        self.__lock__.acquire()
        try:
            try:
                del self.__storage__[get_ident()][name]
            except KeyError:
                raise AttributeError(name)
        finally:
            self.__lock__.release()
#+END_SRC

* wekzeug 包的导入
:PROPERTIES:
:ID:       1DDE9DC3-00E6-488E-A061-9ABBEC9C6EE8
:END:

#+BEGIN_SRC python :results values list :exports no-eval
# -*- coding: utf-8 -*-
"""
    werkzeug
    ~~~~~~~~

    Werkzeug is the Swiss Army knife of Python web development.

    It provides useful classes and functions for any WSGI application to make
    the life of a python web developer much easier.  All of the provided
    classes are independent from each other so you can mix it with any other
    library.


    :copyright: (c) 2010 by the Werkzeug Team, see AUTHORS for more details.
    :license: BSD, see LICENSE for more details.
"""
from types import ModuleType
import sys

# This import magic raises concerns quite often which is why the implementation
# and motiviation is explained here in detail now.
#
# The majority of the functions and classes provided by Werkzeug work on the
# HTTP and WSGI layer.  There is no useful grouping for those which is why
# they are all importable from "werkzeug" instead of the modules where they are
# implemented.  The downside of that is, that now everything would be loaded at
# once, even if unused.
#
# The implementation of a lazy-loading module in this file replaces the
# werkzeug package when imported from within.  Attribute access to the werkzeug
# module will then lazily import from the modules that implement the objects.


# import mapping to objects in other modules
all_by_module = {
    'werkzeug.debug':       ['DebuggedApplication'],
    'werkzeug.local':       ['Local', 'LocalManager', 'LocalProxy',
                             'LocalStack', 'release_local'],
    'werkzeug.templates':   ['Template'],
    'werkzeug.serving':     ['run_simple'],
    'werkzeug.test':        ['Client', 'EnvironBuilder', 'create_environ',
                             'run_wsgi_app'],
    'werkzeug.testapp':     ['test_app'],
    'werkzeug.exceptions':  ['abort', 'Aborter'],
    'werkzeug.urls':        ['url_decode', 'url_encode', 'url_quote',
                             'url_quote_plus', 'url_unquote',
                             'url_unquote_plus', 'url_fix', 'Href',
                             'iri_to_uri', 'uri_to_iri'],
    'werkzeug.formparser':  ['parse_form_data'],
    'werkzeug.utils':       ['escape', 'environ_property', 'cookie_date',
                             'http_date', 'append_slash_redirect', 'redirect',
                             'cached_property', 'import_string',
                             'dump_cookie', 'parse_cookie', 'unescape',
                             'format_string', 'find_modules', 'header_property',
                             'html', 'xhtml', 'HTMLBuilder',
                             'validate_arguments', 'ArgumentValidationError',
                             'bind_arguments', 'secure_filename'],
    'werkzeug.wsgi':        ['get_current_url', 'get_host', 'pop_path_info',
                             'peek_path_info', 'SharedDataMiddleware',
                             'DispatcherMiddleware', 'ClosingIterator',
                             'FileWrapper', 'make_line_iter', 'LimitedStream',
                             'responder', 'wrap_file', 'extract_path_info'],
    'werkzeug.datastructures': ['MultiDict', 'CombinedMultiDict', 'Headers',
                             'EnvironHeaders', 'ImmutableList',
                             'ImmutableDict', 'ImmutableMultiDict',
                             'TypeConversionDict', 'ImmutableTypeConversionDict',
                             'Accept', 'MIMEAccept', 'CharsetAccept',
                             'LanguageAccept', 'RequestCacheControl',
                             'ResponseCacheControl', 'ETags', 'HeaderSet',
                             'WWWAuthenticate', 'Authorization',
                             'FileMultiDict', 'CallbackDict', 'FileStorage',
                             'OrderedMultiDict', 'ImmutableOrderedMultiDict'],
    'werkzeug.useragents':  ['UserAgent'],
    'werkzeug.http':        ['parse_etags', 'parse_date', 'parse_cache_control_header',
                             'is_resource_modified', 'parse_accept_header',
                             'parse_set_header', 'quote_etag', 'unquote_etag',
                             'generate_etag', 'dump_header',
                             'parse_list_header', 'parse_dict_header',
                             'parse_authorization_header',
                             'parse_www_authenticate_header',
                             'remove_entity_headers', 'is_entity_header',
                             'remove_hop_by_hop_headers', 'parse_options_header',
                             'dump_options_header', 'is_hop_by_hop_header',
                             'unquote_header_value',
                             'quote_header_value', 'HTTP_STATUS_CODES'],
    'werkzeug.wrappers':    ['BaseResponse', 'BaseRequest', 'Request',
                             'Response', 'AcceptMixin', 'ETagRequestMixin',
                             'ETagResponseMixin', 'ResponseStreamMixin',
                             'CommonResponseDescriptorsMixin',
                             'UserAgentMixin', 'AuthorizationMixin',
                             'WWWAuthenticateMixin',
                             'CommonRequestDescriptorsMixin'],
    'werkzeug.security':    ['generate_password_hash', 'check_password_hash'],
    # the undocumented easteregg ;-)
    'werkzeug._internal':   ['_easteregg']
}

# modules that should be imported when accessed as attributes of werkzeug
attribute_modules = dict.fromkeys(['exceptions', 'routing', 'script'])


object_origins = {}
for module, items in all_by_module.iteritems():
    for item in items:
        object_origins[item] = module


#: the cached version of the library.  We get the distribution from
#: pkg_resources the first time this attribute is accessed.  Because
#: this operation is quite slow it speeds up importing a lot.
version = None

class module(ModuleType):
    """Automatically import objects from the modules."""

    def __getattr__(self, name):
        if name in object_origins:
            module = __import__(object_origins[name], None, None, [name])
            for extra_name in all_by_module[module.__name__]:
                setattr(self, extra_name, getattr(module, extra_name))
            return getattr(module, name)
        elif name in attribute_modules:
            __import__('werkzeug.' + name)
        return ModuleType.__getattribute__(self, name)

    def __dir__(self):
        """Just show what we want to show."""
        result = list(new_module.__all__)
        result.extend(('__file__', '__path__', '__doc__', '__all__',
                       '__docformat__', '__name__', '__path__',
                       '__package__', '__version__'))
        return result

    @property
    def __version__(self):
        global version
        if version is None:
            try:
                version = __import__('pkg_resources') \
                          .get_distribution('Werkzeug').version
            except:
                version = 'unknown'
        return version

# keep a reference to this module so that it's not garbage collected
old_module = sys.modules['werkzeug']


# setup the new module and patch it into the dict of loaded modules
new_module = sys.modules['werkzeug'] = module('werkzeug')
new_module.__dict__.update({
    '__file__':         __file__,
    '__path__':         __path__,
    '__doc__':          __doc__,
    '__all__':          tuple(object_origins) + tuple(attribute_modules),
    '__docformat__':    'restructuredtext en'
})
#+END_SRC

#+DOWNLOADED: /var/folders/2h/_7667pjd23s4wd9mpdwy401w0000gn/T/screenshot.jpg @ 2019-10-23 18:56:39
[[file:./static/Flask-0.1/screenshot_2019-10-23_18-56-39.jpg]]

#+DOWNLOADED: /var/folders/2h/_7667pjd23s4wd9mpdwy401w0000gn/T/screenshot.jpg @ 2019-10-23 18:50:31
[[file:./static/Flask-0.1/screenshot_2019-10-23_18-50-31.jpg]]
