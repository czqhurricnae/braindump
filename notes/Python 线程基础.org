# -*- eval: (setq org-download-image-dir (concat default-directory "./static/Python 线程基础/")); -*-
:PROPERTIES:
:ID:       2FCAD4B0-022B-4FE9-BF1F-977A8C6512C0
:END:
#+LATEX_CLASS: my-article
#+DATE: <2020-08-04 Tue 21:11>
#+TITLE: Python 线程基础

* 线程状态
状态的转换过程：

[[file:./static/Python 线程基础/1.png]]

* 线程同步锁
考虑这样一种情况：一个列表里所有元素都是 0，线程 “set” 从后向前把所有元素改成 1，而线程 “print” 负责从前往后读取列表并打印。
那么，可能线程 “set” 开始改的时候，线程 “print” 便来打印列表了，输出就成了一半 0 一半 1，这就是数据的不同步。
为了避免这种情况，引入了锁的概念。
锁的两种状态：锁定，未锁定。
线程与锁的交互如下图所示：

[[file:./static/Python 线程基础/2.png]]

* 线程通信
列表并不是一开始就有的；而是通过线程 “create” 创建的。
如果 “set” 或者 “print” 在 “create” 还没有运行的时候就访问列表，将会出现一个异常。
使用锁可以解决这个问题，但是 “set” 和 “print” 将需要一个无限循环——他们不知道 “create” 什么时候会运行，让 “create” 在运行后通知 “set” 和 “print” 显然是一个更好的解决方案。
于是，引入了条件变量。

条件变量允许线程比如 “set” 和 “print” 在条件不满足的时候（列表为 None 时）等待，
等到条件满足的时候（列表已经创建）发出一个通知，告诉 “set” 和 “print” 条件已经有了，你们该起床干活了；然后 “set” 和 “print” 才继续运行。

线程与条件变量的交互如下图所示：

[[file:./static/Python 线程基础/3.png]]

* 线程运行和阻塞的状态转换

[[file:./static/Python 线程基础/4.png]]

阻塞有三种情况：

- 同步阻塞是指处于竞争锁定的状态，线程请求锁定时将进入这个状态，一旦成功获得锁定又恢复到运行状态

- 等待阻塞是指等待其他线程通知的状态，线程获得条件锁定后，调用 “等待” 将进入这个状态，一旦其他线程发出通知，线程将进入同步阻塞状态，再次竞争条件锁定

- 其他阻塞是指调用 ~time.sleep()~ ， ~anotherthread.join()~ 或等待 IO 时的阻塞，这个状态下线程不会释放已获得的锁定
